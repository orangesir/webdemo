java想不到的运行结果10-局部变量的垃圾回收

有些时候我们在局部变量中使用了大内存变量时候，把这个些大内存变量放到{}中，也就是代码块中，这样有个好处，当这个代码块完了后，触发垃圾回收时候，这些大内存变量占用的内存可以得到释放。

不过下面这段代码，执行结果内存却没有释放。
public class App
{
    public static void main( String[] args )
    {
        {
            int[] a = new int[128*1024*1024];
        }
//        int b = 0;
        System.gc();
    }
}
gc日志(使用-verbose:gc参数,命令java -verbose:gc App):
[GC (System.gc())  525557K->524608K(646656K), 0.0019519 secs]
[Full GC (System.gc())  524608K->524549K(646656K), 0.0064667 secs]
可以看到其实内存是没有回收的。
但是把注释掉的这句代码,取消注释,结果如下:
[GC (System.gc())  525557K->524632K(646656K), 0.0049981 secs]
[Full GC (System.gc())  524632K->261K(646656K), 0.0078525 secs]
很明显，a变量的内存被回收了。

这个现象在《深入java虚拟机》中有了描述:
java中每个方法中有个局部变量表，这个表里面有个最小单位局部变量槽（Variable Slot）,a变量所在的代码块执行完以后，虽然后面a变量已经没有了，但是main方法的局部变量表的变量槽也没有被使用，所以垃圾回收机制感知不到，所以a变量作为应该被回收的内存实际上是不会被回收的。第二个执行结果则反应了这个中情况。所以在某个大的局部变量在被使用完后最好是被重新赋值微null。这样即使在这个方法没有执行完成时候，如果触发了垃圾回收，这些大内存变量的内存也会被回收的。
